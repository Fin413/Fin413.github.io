<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake</title>
    <style>
        body {
            margin: 0;
            background-color: black;
        }

        canvas {
            display: block;
            background-color: black;
        }

        #gameOver{
            display: none;
            opacity: 0;
            position: absolute;
            left: 50%;
            top: 30%;
            transform: translateX(-50%);
            color: white;
            white-space: pre;
            font-family: monospace;
            animation: hover 1.5s steps(3) infinite;
        }

        @keyframes hover {
            0% {
                transform: translate(-50%, -5%);
            }

            50% {
                transform: translate(-50%, 5%);
            }

            100% {
                transform: translate(-50%, -5%);
            }
        }
    </style>
</head>
<body>
    <h1 id="gameOver">
 ▗▄▄▖ ▗▄▖ ▗▖  ▗▖▗▄▄▄▖     ▗▄▖ ▗▖  ▗▖▗▄▄▄▖▗▄▄▖ 
▐▌   ▐▌ ▐▌▐▛▚▞▜▌▐▌       ▐▌ ▐▌▐▌  ▐▌▐▌   ▐▌ ▐▌
▐▌▝▜▌▐▛▀▜▌▐▌  ▐▌▐▛▀▀▘    ▐▌ ▐▌▐▌  ▐▌▐▛▀▀▘▐▛▀▚▖
▝▚▄▞▘▐▌ ▐▌▐▌  ▐▌▐▙▄▄▖    ▝▚▄▞▘ ▝▚▞▘ ▐▙▄▄▖▐▌ ▐▌
    </h1>
    <canvas id="canvas"></canvas>
    <script src="explosion.js"></script>
    <script>
        // start screen no clear canvsa moving randomly


        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");

        var pixelSize = 10;
        var speed = 1;

        var snakeSegments = [
            {x: pixelSize * 2, y: 0, dir: { x: 1, y: 0 }},
            {x: pixelSize, y: 0, dir: { x: 1, y: 0 }},
            {x: 0, y: 0, dir: { x: 1, y: 0 }},
        ];
        var dirChanges = [];
        var apples = []

        var allExplosions = [];

        var dead = false;


        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener("resize", resize);

        function loop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawSnake();
            drawApples();

            boundaryCollision();

            allExplosions.forEach((explosion, i) => {
                if(explosion.allParticles.length == 0) allExplosions.splice(i, 1);
                else explosion.update();
            });

            if(!dead) requestAnimationFrame(loop);
        }

        function drawSnake() {
            ctx.fillStyle = "#0F0";

            for (let i = 0; i < snakeSegments.length; ++i) {
                let seg = snakeSegments[i];

                if (i != 0) {
                    let dirChange = null;
                    let minDist = 1;
                    dirChanges.forEach((dirCng, j) => {
                        let xDiff = Math.abs(seg.x - dirCng.x);
                        let yDiff = Math.abs(seg.y - dirCng.y);
                        let tot = xDiff + yDiff;

                        const distTolerance = 0.1;
                        if(tot <= distTolerance && tot < minDist) {
                            minDist = tot;
                            dirChange = dirCng;

                            // remove turn point once tail passes
                            if(i == snakeSegments.length - 1) dirChanges.splice(j, 1);
                        }
                    });

                    if (dirChange) {
                        seg.dir.x = dirChange.dirX;
                        seg.dir.y = dirChange.dirY;
                        seg.x = dirChange.x;
                        seg.y = dirChange.y;
                    }

                    
                    // detect self collisions
                    if(selfCollision(seg)) die();
                }
                console.log(speed)
                seg.x += speed * seg.dir.x;
                seg.y += speed * seg.dir.y;

                ctx.beginPath();
                ctx.rect(seg.x, seg.y, pixelSize, pixelSize);
                ctx.fill();
            }
        }

        function addLength(len) {
            for(let i = 0; i < len; ++i){
                let tailSeg = snakeSegments[snakeSegments.length - 1];
                let newSeg = {
                    x: tailSeg.x + (tailSeg.dir.x * pixelSize * -1),
                    y: tailSeg.y + (tailSeg.dir.y * pixelSize * -1),
                    dir: { 
                        x: tailSeg.dir.x,
                        y: tailSeg.dir.y,
                    },
                }
                snakeSegments.push(newSeg);
            }
        }

        function drawApples() {
            for (let i = 0; i < apples.length; ++i) {
                let apple = apples[i];

                ctx.fillStyle = "#F00";
                ctx.beginPath();
                ctx.rect(apple.x, apple.y, pixelSize, pixelSize);
                ctx.fill();

                // detect collisions
                let head = snakeSegments[0]; 
                let eatTolerance = pixelSize;

                if(Math.abs(head.x - apple.x) < eatTolerance && Math.abs(head.y - apple.y) < eatTolerance){
                    apples.splice(i, 1);
                    allExplosions.push(new Explosion(apple.x, apple.y, ctx, "#F00"));
                    allExplosions.push(new Explosion(apple.x, apple.y, ctx, "#F00"));
                    addLength(10);
                    spawnApple(10);
                }
            }
        }

        function spawnApple(num) {
            for(let i = 0; i < num; ++i){
                apples.push({
                    x: randFloat(pixelSize, window.innerWidth - pixelSize),
                    y: randFloat(pixelSize, window.innerHeight - pixelSize)
                });
            }
        }

        function boundaryCollision() {
            let head = snakeSegments[0];
            
            let outOfXBounds = head.x > window.innerWidth || head.x < 0;
            let outofYBounds = head.y < 0 || head.y > window.innerHeight;
            if(outOfXBounds || outofYBounds) die();
        }

        function selfCollision(seg) {
            let head = snakeSegments[0];
            const tolerance = 0.1;
            
            let headBox = {
                x: head.x,
                y: head.y,
            }

            let segBox = {
                x: seg.x,
                y: seg.y,
            }

            if(head.dir.y != 0){
                if (head.dir.y == 1) headBox.y += pixelSize;
                else if (head.dir.y == -1) segBox.y += pixelSize;
                let xDiff = Math.abs(headBox.x - segBox.x);
                let yDiff = Math.abs(headBox.y - segBox.y);
                if(yDiff < tolerance && xDiff < pixelSize) return true;
            }

            if(head.dir.x != 0){
                if (head.dir.x == 1) headBox.x += pixelSize;
                else if (head.dir.x == -1) segBox.x += pixelSize;
                let xDiff = Math.abs(headBox.x - segBox.x);
                let yDiff = Math.abs(headBox.y - segBox.y);
                if(xDiff < tolerance && yDiff < pixelSize) return true;
            }
           
            return false;
        }

        function die() {
            // dead = true;
            let deathText = document.getElementById("gameOver");
            deathText.style.display = "block";

            speed = 0;

            var head = snakeSegments[0];
            allExplosions.push(new Explosion(head.x, head.y, ctx, "#0F0"));

            setTimeout(() => {
                dead = true;
                let opacity = 0;
                const updateOpacity = () => {
                    opacity += 0.2;
                    deathText.style.opacity = opacity;
                    if(opacity != 1) setTimeout(updateOpacity, 500);
                }
                updateOpacity();    
            }, 500)
        }

        function randFloat (min, max) {
            return Math.random() * (max - min) + min;
        };

        function init() {
            resize();
            loop();
            spawnApple(1);
            addLength(10);
        }
        init();

        const validKeys = ["w", "a", "s", "d"];
        window.addEventListener("keydown", e => {
            let key = e.key.toLowerCase();
            if(validKeys.includes(key)){
                let head = snakeSegments[0];
    
                if(key == "d" && head.dir.x != -1) {
                    head.dir.x = 1;
                    head.dir.y = 0;
                } else if(key == "a" && head.dir.x != 1){
                    head.dir.x = -1;
                    head.dir.y = 0;
                } 
    
                if(key == "w" && head.dir.y != 1) {
                    head.dir.y = -1;
                    head.dir.x = 0;
                } else if (key == "s" && head.dir.y != -1) {
                    head.dir.y = 1;
                    head.dir.x = 0;
                }
    
                if(head.dir.x != 0 || head.dir.y != 0) {
                    dirChanges.push({
                        x: snakeSegments[0].x, 
                        y: snakeSegments[0].y,
                        dirX: head.dir.x,
                        dirY: head.dir.y,
                    });
                }
            }
        });

    </script>
</body>
</html>